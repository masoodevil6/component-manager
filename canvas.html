<!--<svg id="mysvg" width="400" height="200" style="border:1px solid #ccc"></svg>

<script>
  // Ù…Ø®ØªØµØ§Øª Ø³Ù‡ Ù†Ù‚Ø·Ù‡
  const points = [
    { x: 50,  y: 150 },
    { x: 200, y: 50  },
    { x: 350, y: 150 }
  ];

  const svg = document.getElementById("mysvg");

  // Ø³Ø§Ø®Øª Ø®Ø· (polyline)
  const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
  polyline.setAttribute("points", points.map(p => `${p.x},${p.y}`).join(" "));
  polyline.setAttribute("stroke", "black");
  polyline.setAttribute("stroke-width", "2");
  polyline.setAttribute("fill", "none");
  svg.appendChild(polyline);

  // Ø³Ø§Ø®Øª Ø¯Ø§ÛŒØ±Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù†Ù‚Ø·Ù‡
  points.forEach(p => {
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", p.x);
    circle.setAttribute("cy", p.y);
    circle.setAttribute("r", 5);
    circle.setAttribute("fill", "red");
    svg.appendChild(circle);
  });
</script>-->








<!--<svg id="mysvg2" width="400" height="200" style="border:1px solid #ccc"></svg>

<script>
  // Ø³Ù‡ Ù†Ù‚Ø·Ù‡
  const points = [
    { x: 50,  y: 150 },
    { x: 200, y: 50  },
    { x: 350, y: 150 }
  ];

  const svg = document.getElementById("mysvg2");

  // Ù…Ø³ÛŒØ± Ù…Ù†Ø­Ù†ÛŒ (Cubic Bezier)
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  const d = `M ${points[0].x},${points[0].y}
             Q ${points[1].x},${points[1].y}
               ${points[2].x},${points[2].y}`;
  path.setAttribute("d", d);
  path.setAttribute("stroke", "black");
  path.setAttribute("stroke-width", "2");
  path.setAttribute("fill", "none");
  svg.appendChild(path);

  // Ù†Ù…Ø§ÛŒØ´ Ø³Ù‡ Ù†Ù‚Ø·Ù‡ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø§ÛŒØ±Ù‡
  points.forEach(p => {
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", p.x);
    circle.setAttribute("cy", p.y);
    circle.setAttribute("r", 5);
    circle.setAttribute("fill", "red");
    svg.appendChild(circle);
  });
</script>-->







<!--
<svg id="mysvg2" width="1500" height="1500" style="border:1px solid #ccc"></svg>

<script>
  // Ø³Ù‡ Ù†Ù‚Ø·Ù‡
  const points = [
    { x: 0,  y: 0 },
    { x: 450, y: 360  },
    { x: 500, y: 400 } ,
    { x: 550,  y: 360 },
    { x: 1000, y: 0  }
  ];

  const svg = document.getElementById("mysvg2");


  const polyline1 = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
  polyline1.setAttribute("points", `${points[0].x},${points[0].y}  ${points[1].x},${points[1].y}`);
  polyline1.setAttribute("stroke", "black");
  polyline1.setAttribute("stroke-width", "2");
  polyline1.setAttribute("fill", "none");
  svg.appendChild(polyline1);





  const polyline2 = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
  polyline2.setAttribute("points", `${points[3].x},${points[3].y}  ${points[4].x},${points[4].y}`);
  polyline2.setAttribute("stroke", "black");
  polyline2.setAttribute("stroke-width", "2");
  polyline2.setAttribute("fill", "none");
  svg.appendChild(polyline2);


  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  const d = `M ${points[1].x},${points[1].y}
             Q ${points[2].x},${points[2].y}
               ${points[3].x},${points[3].y}`;
  path.setAttribute("d", d);
  path.setAttribute("stroke", "black");
  path.setAttribute("stroke-width", "2");
  path.setAttribute("fill", "none");
  svg.appendChild(path);


  // Ù†Ù…Ø§ÛŒØ´ Ø³Ù‡ Ù†Ù‚Ø·Ù‡ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø§ÛŒØ±Ù‡
  points.forEach(p => {
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", p.x);
    circle.setAttribute("cy", p.y);
    circle.setAttribute("r", 5);
    circle.setAttribute("fill", "red");
    svg.appendChild(circle);
  });

</script>
-->



<!--<svg id="mysvg" width="400" height="200" style="border:1px solid #ccc"></svg>

<script>
  const svg = document.getElementById("mysvg");

  // Ø³Ù‡ Ù†Ù‚Ø·Ù‡ Ù†Ù…ÙˆÙ†Ù‡
  const points = [
    { x: 50,  y: 150 },
    { x: 200, y: 50  },
    { x: 350, y: 150 }
  ];

  // Ø³Ø§Ø®Øª Ø¯Ø§ÛŒØ±Ù‡â€ŒÙ‡Ø§
  points.forEach((p, i) => {
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", p.x);
    circle.setAttribute("cy", p.y);
    circle.setAttribute("r", 8);
    circle.setAttribute("fill", "red");
    circle.style.cursor = "pointer";
    svg.appendChild(circle);

    // drag callback
    let isDragging = false;

    circle.addEventListener("mousedown", (e) => {
      isDragging = true;
    });

    svg.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      // Ù…Ø®ØªØµØ§Øª Ù…ÙˆØ³ Ù†Ø³Ø¨Øª Ø¨Ù‡ SVG
      const pt = svg.createSVGPoint();
      pt.x = e.clientX;
      pt.y = e.clientY;
      const cursorpt = pt.matrixTransform(svg.getScreenCTM().inverse());

      // Ø¨Ø±ÙˆØ² Ø±Ø³Ø§Ù†ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ø§ÛŒØ±Ù‡
      circle.setAttribute("cx", cursorpt.x);
      circle.setAttribute("cy", cursorpt.y);

      // Ú©Ø§Ù„ Ø¨Ú©: Ù…Ø«Ù„Ø§ Ù…ÛŒâ€ŒØ®ÙˆØ§ÛŒ Ù…Ø®ØªØµØ§Øª Ø¬Ø¯ÛŒØ¯ Ø±Ùˆ Ú†Ø§Ù¾ Ú©Ù†ÛŒ
      console.log(`Point ${i}: x=${cursorpt.x}, y=${cursorpt.y}`);
    });

    document.addEventListener("mouseup", () => {
      isDragging = false;
    });
  });
</script>-->



<!--
<svg id="mysvg" width="400" height="200" style="border:1px solid #ccc">

  <defs>
    <marker id="arrow" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth">
      <path d="M0,0 L0,6 L9,3 z" fill="black" />
    </marker>

    <marker id="arrow2" markerWidth="10" markerHeight="10" refX="3" refY="3" orient="auto">
      <path d="M0,0 L3,3 L0,6 L9,3 z" fill="black" />
    </marker>
  </defs>


</svg>

<script>
  // Ù…Ø®ØªØµØ§Øª Ø³Ù‡ Ù†Ù‚Ø·Ù‡
  const points = [
    { x: 50,  y: 150 },
    { x: 200, y: 50  }
  ];

  const svg = document.getElementById("mysvg");

  // Ø³Ø§Ø®Øª Ø®Ø· (polyline)
  const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
  polyline.setAttribute("points", points.map(p => `${p.x},${p.y}`).join(" "));
  polyline.setAttribute("stroke", "black");
  polyline.setAttribute("stroke-width", "2");
  polyline.setAttribute("fill", "none");
  polyline.setAttribute("marker-end", "url(#arrow2)");
  svg.appendChild(polyline);

 /* // Ø³Ø§Ø®Øª Ø¯Ø§ÛŒØ±Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù†Ù‚Ø·Ù‡
  points.forEach(p => {
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", p.x);
    circle.setAttribute("cy", p.y);
    circle.setAttribute("r", 5);
    circle.setAttribute("fill", "red");
    svg.appendChild(circle);
  });*/
</script>-->



<!--
<svg id="mysvg" width="400" height="200" style="border:1px solid #ccc"></svg>

<script>
  const svg = document.getElementById("mysvg");

  // Ø³Ø§Ø®Øª foreignObject
  const foreign = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
  foreign.setAttribute("x", 100);   // Ù…Ø®ØªØµØ§Øª X
  foreign.setAttribute("y", 100);   // Ù…Ø®ØªØµØ§Øª Y
  foreign.setAttribute("width", 120);
  foreign.setAttribute("height", 50);

  // Ø³Ø§Ø®Øª ÛŒÚ© div Ø¯Ø§Ø®Ù„ foreignObject
  const div = document.createElement("div");
  div.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"); // Ù…Ù‡Ù… Ø¨Ø±Ø§ÛŒ HTML Ø¯Ø§Ø®Ù„ SVG
  div.style.fontSize = "14px";
  div.style.color = "blue";
  div.innerText = "Ø³Ù„Ø§Ù… ğŸ‘‹ Ù…ØªÙ† HTML Ø¯Ø§Ø®Ù„ SVG";

  // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† div Ø¨Ù‡ foreignObject
  foreign.appendChild(div);

  // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† foreignObject Ø¨Ù‡ SVG
  svg.appendChild(foreign);
</script>
-->



<style>
  #form-scroller{
    width: 1000px;
    height: 1000px;
    overflow: auto;
    scrollbar-width: none;
    cursor: all-scroll;
    border: #969696 solid 2px;
    background-color: #f5f5f5;
    user-select: none;       /* Ù…ØªÙ† Ù‚Ø§Ø¨Ù„ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø¨Ø§Ø´Ø¯ */
    -webkit-user-select: none; /* Chrome/Safari */
    -moz-user-select: none;    /* Firefox */
    -ms-user-select: none;     /* IE/Edge */
  }

  #form-scroller::-webkit-scrollbar {
    display: none;        /* Chrome, Safari, Edge */
  }

</style>

<section id="form-scroller">
  <div id="body-scroller">
    <svg id="mysvg" width="2500" height="2500" style="border:1px solid #ccc" >
      <defs></defs>
    </svg>
  </div>
</section>


<script>

  const section = document.getElementById("form-scroller");
  const sectionScrollerBody = document.getElementById("body-scroller");

  let isDown = false;  // Ø¢ÛŒØ§ Ú©Ù„ÛŒÚ© Ù†Ú¯Ù‡ Ø¯Ø§Ø´ØªÙ‡ Ø´Ø¯Ù‡ØŸ
  let startX, startY;  // Ù…ÙˆÙ‚Ø¹ÛŒØª Ø§ÙˆÙ„ÛŒÙ‡ Ù…ÙˆØ³
  let scrollLeft, scrollTop; // Ù…ÙˆÙ‚Ø¹ÛŒØª Ø§ÙˆÙ„ÛŒÙ‡ scroll
  let scale = 1;
  const minScale = 0.2;
  const maxScale = 5;

  section.addEventListener("mousedown", e => {
    isDown = true;
    startX = e.pageX - section.offsetLeft;
    startY = e.pageY - section.offsetTop;
    scrollLeft = section.scrollLeft;
    scrollTop = section.scrollTop;

    e.preventDefault(); // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø§Ù†ØªØ®Ø§Ø¨ Ù…ØªÙ†
  });

  section.addEventListener("mousemove", e => {
    if (!isDown) return;
    e.preventDefault();  // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø±ÙØªØ§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ù…Ø±ÙˆØ±Ú¯Ø±
    const x = e.pageX - section.offsetLeft;
    const y = e.pageY - section.offsetTop;
    const walkX = (x - startX) * -1;
    const walkY = (y - startY) * -1;
    section.scrollLeft = scrollLeft + walkX;
    section.scrollTop  = scrollTop + walkY;
  });

  function applyZoom() {
    sectionScrollerBody.style.transform = `scale(${scale})`;
    sectionScrollerBody.style.transformOrigin = "0 0"; // Ù‡Ù…ÛŒØ´Ù‡ Ø¨Ø§Ù„Ø§-Ú†Ù¾
  }

  section.addEventListener("wheel", (e) => {
    e.preventDefault();

    // Ù…ÙˆÙ‚Ø¹ÛŒØª Ù…ÙˆØ³ Ù†Ø³Ø¨Øª Ø¨Ù‡ section
    const rect = section.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Ù…Ù‚Ø¯Ø§Ø± Ø²ÙˆÙ…
    const zoomSpeed = 0.001;
    const newScale = Math.min(Math.max(scale - e.deltaY * zoomSpeed, minScale), maxScale);
    const scaleRatio = newScale / scale;

    // Ù…Ø­Ø§Ø³Ø¨Ù‡ scroll Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø«Ø§Ø¨Øª Ù†Ú¯Ù‡ Ø¯Ø§Ø´ØªÙ† Ù†Ù‚Ø·Ù‡ Ø²ÛŒØ± Ù…ÙˆØ³
    section.scrollLeft = (section.scrollLeft + mouseX) * scaleRatio - mouseX;
    section.scrollTop  = (section.scrollTop + mouseY)  * scaleRatio - mouseY;

    scale = newScale;
    applyZoom();
  });
  section.addEventListener("mouseleave", () => isDown = false);
  section.addEventListener("mouseup", () => isDown = false);





  function addDefsForMarker(svg){
    let svgDefs = svg.getElementsByTagName("defs");
    if (svgDefs == null){
      svg.innerText = svg.innerText + "<defs></defs>";
    }
    return svg.getElementsByTagName("defs")[0];
  }
  function addMarker(svg , markerName, bgColor){

    let svgDefs = addDefsForMarker(svg);
    let markerHtml = null;
    let markerId = `#${markerName}_${Math.random()*1000}`;
    switch (markerName){
      case "arrow":
        markerHtml = `
        <marker id="${markerId}" markerWidth="10" markerHeight="10" refX="3" refY="3" orient="auto">
          <path d="M0,0 L3,3 L0,6 L9,3 z" fill="${bgColor}" />
        </marker>
        `;
        break;
      case "circle":
        markerHtml = `
        <marker id="${markerId}" markerWidth="20" markerHeight="20" refX="10" refY="10" orient="auto" markerUnits="strokeWidth" >
          <circle cx="10" cy="10" r="3" fill="white" stroke="${bgColor}" stroke-width="1"  style="pointer-events:none; cursor:pointer;" />
        </marker>
        `;
        break;
    }

    if (markerHtml != null){
      svgDefs.innerHTML = svgDefs.innerHTML + markerHtml;
      return markerId;
    }

    return null;
  }



  function getPointInLinWithPercent(pointA , pointB , isStart=true , percent=0.1){
    return {
      x: (isStart ? percent : (1-percent)) * (pointB.x - pointA.x) + pointA.x ,
      y: (isStart ? percent : (1-percent)) * (pointB.y - pointA.y) + pointA.y ,
    }
  }

  function getPointInLinWithLength(pointA , pointB , isStart=true , length=10){
    const d = Math.sqrt(Math.pow(pointB.x - pointA.x, 2) + Math.pow(pointB.y - pointA.y, 2));
    const p = length/d;
    return getPointInLinWithPercent(pointA , pointB , isStart , p);
  }

  function connectDirectionPoint(svgId , points , lineWidth=2 , animDuration=250 , bgColor="#9b9b9b"){

    const svg = document.getElementById(svgId);

    const pointsProgressed = [];
    if (points != null && Array.isArray(points)){
      for (let i = 0; i < points.length ; i++) {
        const pointSelected = points[i];

        let isJoin = true;
        if (i == 0 || i == points.length -1){
          isJoin = false;
        }

        if (isJoin){
          const pointAB = getPointInLinWithLength(points[i-1] , points[i]  , false);
          pointSelected.isJoin = true;
          const pointBC = getPointInLinWithLength(points[i]  , points[i+1] , true);
          pointsProgressed.push(...[pointAB , pointSelected , pointBC])
        }
        else {
          pointsProgressed.push(pointSelected)
        }
      }
    }

    let animTimer = 0;
    for (let i = 0; i < pointsProgressed.length-1 ; i++) {
      const pointPrevious = pointsProgressed[i-1];
      const pointSelected = pointsProgressed[i];
      const pointNext = pointsProgressed[i+1];

      if (!pointNext.hasOwnProperty("isJoin") || !pointNext.isJoin){
        if (pointSelected.hasOwnProperty("isJoin") && pointSelected.isJoin){
          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          const d = `M ${pointPrevious.x},${pointPrevious.y}
             Q ${pointSelected.x},${pointSelected.y}
               ${pointNext.x},${pointNext.y}`;
          path.setAttribute("d", d);
          path.setAttribute("stroke", bgColor);
          path.setAttribute("stroke-width", lineWidth);
          path.setAttribute("fill", "none");
          svg.appendChild(path);

          const length = path.getTotalLength();
          path.setAttribute("stroke-dasharray", length);
          path.setAttribute("stroke-dashoffset", length);



          const animate = document.createElementNS("http://www.w3.org/2000/svg", "animate");
          animate.setAttribute("attributeName", "stroke-dashoffset");
          animate.setAttribute("from", length);
          animate.setAttribute("to", 0);
          animate.setAttribute("dur", animDuration/2+"ms");
          animate.setAttribute("fill", "freeze");
          animate.setAttribute("begin", "indefinite"); // âŒ
          setTimeout(() => {
            requestAnimationFrame(() => {
              path.getBoundingClientRect(); // force reflow
              path.style.transition = `stroke-dashoffset ${animDuration}ms linear`;
              path.style.strokeDashoffset = '0';
            });
            animate.beginElement();
          }, animTimer);
          path.appendChild(animate);

          animTimer +=animDuration/2
        }
        else {
          const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
          polyline.setAttribute("points", `${pointSelected.x},${pointSelected.y}  ${pointNext.x},${pointNext.y}`);
          polyline.setAttribute("stroke", bgColor);
          polyline.setAttribute("stroke-width", lineWidth);
          polyline.setAttribute("fill", "none");
          if (pointSelected.hasOwnProperty("markerStart") && pointSelected.markerStart != null){
            const markerId = addMarker(svg , pointSelected.markerStart , bgColor)
            if (markerId != null ){
              polyline.setAttribute("marker-start", `url(#${markerId})`);
            }
          }
          if (pointNext.hasOwnProperty("markerEnd") && pointNext.markerEnd != null){
            setTimeout(()=>{
              const markerId = addMarker(svg , pointNext.markerEnd , bgColor)
              if (markerId != null ){
                polyline.setAttribute("marker-end", `url(#${markerId})`);
              }
            } , animTimer)
          }
          svg.appendChild(polyline);

          const length = polyline.getTotalLength();
          polyline.setAttribute("stroke-dasharray", length);
          polyline.setAttribute("stroke-dashoffset", length);



          const animate = document.createElementNS("http://www.w3.org/2000/svg", "animate");
          animate.setAttribute("attributeName", "stroke-dashoffset");
          animate.setAttribute("from", length);
          animate.setAttribute("to", 0);
          animate.setAttribute("dur", animDuration+"ms");
          animate.setAttribute("fill", "freeze");
          //animate.setAttribute("begin", animTimer+"ms");
          animate.setAttribute("begin", "indefinite"); // âŒ
          polyline.appendChild(animate);

          setTimeout(() => {
            requestAnimationFrame(() => {
              polyline.getBoundingClientRect(); // force reflow
              polyline.style.transition = `stroke-dashoffset ${animDuration}ms linear`;
              polyline.style.strokeDashoffset = '0';
            });
            animate.beginElement();
          }, animTimer);

          animTimer +=animDuration;

        }
      }
    }
  }

  function createHtmlOnPoint(svgId , html , point , animDuration=100 ){
    const svg = document.getElementById(svgId);

    const foreign = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
    foreign.setAttribute("x", point.x);   // Ù…Ø®ØªØµØ§Øª X
    foreign.setAttribute("y", point.y);   // Ù…Ø®ØªØµØ§Øª Y
    foreign.setAttribute("width", point.width);
    foreign.setAttribute("height", point.height);
    foreign.style.position = "relative";
    foreign.style.zIndex = 2;

    foreign.insertAdjacentHTML('beforeend', html);
    svg.appendChild(foreign);

    const animY = document.createElementNS("http://www.w3.org/2000/svg", "animate");
    animY.setAttribute("attributeName", "y");
    animY.setAttribute("from", point.y - 60);
    animY.setAttribute("to", point.y);
    animY.setAttribute("dur", animDuration + "ms");
    animY.setAttribute("fill", "freeze");

    foreign.appendChild(animY);
  }

  function connectTwoPointWithTreeHierarchy(svgId , objectA , objectB , LYmin=20 , lineWidth=2 , animDuration=250 , bgColor="#9b9b9b"  , markers={ start:"" , end:"arrow"}   ){

    let points = null
    if (objectA.x  != objectB.x){

      if (objectB.y >= objectA.y + LYmin){
        const mid = ((objectB.y - objectA.y)/2);
        points = [
          { x: objectA.x , y: objectA.y                   , markerStart:markers != null && markers.hasOwnProperty("start") ? markers.start: null} ,
          { x: objectA.x , y: objectA.y + mid                } ,
          { x: objectB.x , y: objectB.y - mid                } ,
          { x: objectB.x , y: objectB.y                   , markerEnd:markers != null && markers.hasOwnProperty("end") ? markers.end: null} ,
        ]
      }
      else{
        const mid = ((objectB.x - objectA.x)/2);
        points = [
          {x: objectA.x         , y: objectA.y            , markerStart:markers != null && markers.hasOwnProperty("start") ? markers.start: null} ,
          { x: objectA.x        , y: objectA.y + LYmin                 },
          { x: objectA.x + mid  , y: objectA.y + LYmin                 },
          { x: objectB.x - mid  , y: objectB.y - LYmin                 },
          { x: objectB.x        , y: objectB.y - LYmin                 },
          { x: objectB.x        , y: objectB.y            , markerEnd:markers != null && markers.hasOwnProperty("end") ? markers.end: null} ,
        ]
      }
    }
    else {
      points = [
        { x: objectA.x , y: objectA.y                    , markerStart:markers != null && markers.hasOwnProperty("start") ? markers.start: null} ,
        { x: objectB.x , y: objectB.y                    , markerEnd:markers != null && markers.hasOwnProperty("end") ? markers.end: null} ,
      ]
    }

    connectDirectionPoint(svgId , points , lineWidth ,animDuration , bgColor);
  }





  function chartTreeY_buildTree(data, parentId = 0) {
    return data
            .filter(item => item.parent === parentId)
            .map(item => ({
              ...item,
              children: chartTreeY_buildTree(data, item.id)
            }));
  }

  function chartTreeY_assignPositions(node, depth = 0, colCounter = { value: 1 }) {
    node.row = depth;

    if (node.children.length === 0) {
      node.col = colCounter.value;
      colCounter.value += 2;
    } else {
      node.children.forEach(child => chartTreeY_assignPositions(child, depth + 1, colCounter));
      const minCol = node.children[0].col;
      const maxCol = node.children[node.children.length - 1].col;
      node.col = Math.floor((minCol + maxCol) / 2);
    }
  }

  function chartTreeY_flatten(tree, out = []) {
    tree.forEach(node => {
      out.push(node);
      chartTreeY_flatten(node.children, out);
    });
    return out;
  }

  function chartTreeY_closeLevelDefault(objects , templateOptions){
    const levelClose = templateOptions.hasOwnProperty("levelClose") ? templateOptions.levelClose : null;
    if (levelClose != null){
      for (let i = 0; i < objects.length; i++) {
        const item = objects[i];

        if (item !=null && item.hasOwnProperty("row") && item.row == levelClose-1 && item.hasOwnProperty("children") && item.children.length >0){
          objects[i].isOpen = false;
        }
      }
    }
    return objects;
  }

  function chartTreeY_getPosition(objects , templateOptions) {
    const Width =   templateOptions.hasOwnProperty("W")  ? templateOptions.W  : 100;
    const Height =  templateOptions.hasOwnProperty("H")  ? templateOptions.H  : 100;
    const h =       templateOptions.hasOwnProperty("h")  ? templateOptions.h  : 30;
    const dHeight = templateOptions.hasOwnProperty("dH") ? templateOptions.dH : 50;

    for (let i = 0; i < objects.length ; i++) {
      const itemObject = objects[i];
      if (itemObject.hasOwnProperty("row") && itemObject.hasOwnProperty("col")){
        objects[i].x = itemObject.col*(Width) + ((Width)/2);
        objects[i].y = (itemObject.row)*(Height+2*dHeight) + (dHeight + h);
      }
    }
    return objects;
  }

  function chartTreeY_getTemplate(objects , template) {

    for (let i = 0; i < objects.length ; i++) {
      const itemObject = objects[i];
      const tags = itemObject.hasOwnProperty("tags") ? itemObject.tags : {};
      tags["id"] = itemObject.id
      tags["parent"] = itemObject.parent

      objects[i].template = template.replace(/{{(.*?)}}/g, (match, key) => {
        return tags[key.trim()] ?? "";
      });

    }
    return objects;
  }

  function chartTreeY_drawStatus(objects, topDoClose = false) {
    // Ú©Ù¾ÛŒ Ø³Ø·Ø­ÛŒ Ø§Ø² Ø¢Ø¨Ø¬Ú©Øªâ€ŒÙ‡Ø§ (Ø§Ú¯Ø± Ù†ÛŒØ§Ø² Ø¨Ù‡ Ú©Ù¾ÛŒ Ø¹Ù…ÛŒÙ‚â€ŒØªØ±ÛŒ Ø¯Ø§Ø±ÛŒØŒ
    // Ø§Ø² JSON.parse(JSON.stringify(objects)) ÛŒØ§ Ø±ÙˆØ´ Ø¯Ù„Ø®ÙˆØ§Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†)
    const objectsCopy = objects.map(item => ({ ...item, tags: { ...item.tags } }));

    // Ù†Ù‚Ø´Ù‡ id -> node Ø¨Ø±Ø§ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ø³Ø±ÛŒØ¹
    const map = {};
    objectsCopy.forEach(item => map[item.id] = item);

    // Ù†Ù‚Ø´Ù‡ parent -> [children]
    const childrenMap = {};
    objectsCopy.forEach(item => {
      if (!childrenMap[item.parent]) childrenMap[item.parent] = [];
      childrenMap[item.parent].push(item);
    });

    // ØªØ§Ø¨Ø¹ÛŒ Ø¨Ø±Ø§ÛŒ Ø¨Ø³ØªÙ† ØªÙ…Ø§Ù… ÙØ±Ø²Ù†Ø¯Ø§Ù† (Ø¨Ø§Ø²Ú¯Ø´ØªÛŒ)
    function closeChildren(node) {
      const children = childrenMap[node.id] || [];
      children.forEach(child => {
        child.isOpen = false;
        closeChildren(child);
      });
    }

    // Ù‡Ù…Ù‡ Ù†ÙˆØ¯Ù‡Ø§ÛŒÛŒ Ú©Ù‡ ÙØ¹Ù„Ø§Ù‹ isOpen === false Ù‡Ø³ØªÙ†Ø¯
    const closedNodes = objectsCopy.filter(n => n.isOpen === false);

    // ÙÛŒÙ„ØªØ± Ú©Ø±Ø¯Ù†: ÙÙ‚Ø· Ù†ÙˆØ¯Ù‡Ø§ÛŒÛŒ Ú©Ù‡ Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ù†ÙˆØ¯ Ø¨Ø³ØªÙ‡ Ø¯Ø± Ø´Ø§Ø®Ù‡Ù” Ø®ÙˆØ¯ Ù‡Ø³ØªÙ†Ø¯
    // (ÛŒØ¹Ù†ÛŒ Ù‡ÛŒÚ† ÛŒÚ© Ø§Ø² ÙˆØ§Ù„Ø¯Ù‡Ø§ÛŒØ´Ø§Ù† isOpen === false Ù†Ø¨Ø§Ø´Ø¯)
    const topClosedNodes = closedNodes.filter(node => {
      let p = map[node.parent];
      while (p) {
        if (p.isOpen === false) {
          // Ø§Ú¯Ø± ÛŒÚ© ÙˆØ§Ù„Ø¯ Ø¨Ø³ØªÙ‡ Ù¾ÛŒØ¯Ø§ Ø´Ø¯ØŒ Ø§ÛŒÙ† node Ø¯ÛŒÚ¯Ø± top-most Ù†ÛŒØ³Øª
          return false;
        }
        p = map[p.parent];
      }
      return true; // Ù‡ÛŒÚ† ÙˆØ§Ù„Ø¯ Ø¨Ø³ØªÙ‡â€ŒØ§ÛŒ Ù†Ø¨ÙˆØ¯ => Ø§ÛŒÙ† top-most Ø§Ø³Øª
    });

    // Ø­Ø§Ù„Ø§ ÙÙ‚Ø· Ù‡Ù…ÛŒÙ† top-most Ù‡Ø§ Ø±Ø§ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ù†
    topClosedNodes.forEach(topClosed => {
      // Ø§Ú¯Ø± Ø¨Ø®ÙˆØ§Ù‡ÛŒÙ… Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ø±Ø§ Ø¨Ø§Ø²/Ø¨Ø³ØªÙ‡ Ú©Ù†ÛŒÙ…:
      topClosed.isOpen = !topDoClose; // Ø§Ú¯Ø± topDoClose=false â†’ Ø¨Ø§Ø² Ø´ÙˆØ¯ (true)
      // Ùˆ Ø³Ù¾Ø³ Ù‡Ù…Ù‡Ù” ÙØ±Ø²Ù†Ø¯Ø§Ù† Ø¢Ù† Ø±Ø§ Ø¨Ø¨Ù†Ø¯ÛŒÙ…
      closeChildren(topClosed);
    });

    return objectsCopy;
  }


  function chartTreeY_drawShape(svgId , objects , templateOptions) {
    const Width = templateOptions.hasOwnProperty("W") ? templateOptions.W : 100;
    const Height = templateOptions.hasOwnProperty("H") ? templateOptions.H : 100;
    const marginX =  templateOptions.hasOwnProperty("marginX") ? templateOptions.marginX : 100;
    const marginY =  templateOptions.hasOwnProperty("marginY") ? templateOptions.marginY : 100;
    const zoomCenter =  templateOptions.hasOwnProperty("zoomCenter") ? templateOptions.zoomCenter : false;

    let objectStatus = chartTreeY_drawStatus(objects);
    for (let i = 0; i < objectStatus.length ; i++) {
      const itemObject = objectStatus[i];

      if (itemObject != null && ((itemObject.hasOwnProperty("isOpen") && itemObject.isOpen) || !itemObject.hasOwnProperty("isOpen"))){

        if (itemObject.hasOwnProperty("template") && itemObject.hasOwnProperty("x") && itemObject.hasOwnProperty("y")){
          const template = itemObject.template;
          const x = itemObject.x + marginX;
          const y = itemObject.y + marginY;

          createHtmlOnPoint(
                  svgId,
                  template ,
                  { x: x-(Width/2) , y: y  , width:Width+5 , height:Height+5}
          )

          if (zoomCenter && i==0){
            section.scrollLeft = x - section.clientWidth  / 2 ;
            section.scrollTop  = y - section.clientHeight / 2 + 200 ;
          }
        }

      }

    }
    return objects;
  }

  function chartTreeY_drawLine(svgId , objects , templateOptions) {
    const Height =        templateOptions.hasOwnProperty("H")            ? templateOptions.H               : 100;
    const marginX =       templateOptions.hasOwnProperty("marginX")      ? templateOptions.marginX         : 100;
    const marginY =       templateOptions.hasOwnProperty("marginY")      ? templateOptions.marginY         : 100;
    const lYMin =         templateOptions.hasOwnProperty("lYMin")        ? templateOptions.lYMin           : 20;
    const lineWidth =     templateOptions.hasOwnProperty("lineWidth")    ? templateOptions.lineWidth       : 2;
    const animDuration =  templateOptions.hasOwnProperty("animDuration") ? templateOptions.animDuration    : 250;
    const bgColor =       templateOptions.hasOwnProperty("animDuration") ? templateOptions.bgColor         : "#9b9b9b";
    const markerEnd =     templateOptions.hasOwnProperty("markerEnd")    ? templateOptions.markerEnd       : "arrow";
    const markerStat =    templateOptions.hasOwnProperty("markerStat")   ? templateOptions.markerStat       : "plusMarker";

    let objectStatus = chartTreeY_drawStatus(objects , true);
    for (let i = 0; i < objectStatus.length ; i++) {
      const itemObject = objectStatus[i];

      if (itemObject != null && ((itemObject.hasOwnProperty("isOpen") && itemObject.isOpen) || !itemObject.hasOwnProperty("isOpen"))){
        if (itemObject.hasOwnProperty("x") && itemObject.hasOwnProperty("y") && itemObject.hasOwnProperty("children")){
          const children = itemObject.children;
          const positionX1 = itemObject.x + marginX;
          const positionY1 = itemObject.y + Height + marginY;

          for (let j = 0; j < children.length; j++) {
            const itemChild = children[j];
            if (itemChild.hasOwnProperty("x") && itemChild.hasOwnProperty("y")){
              const positionX2 = itemChild.x + marginX;
              const positionY2 = itemChild.y - 10 + marginY;

              connectTwoPointWithTreeHierarchy(
                      svgId ,
                      {x: positionX1 , y:positionY1} ,
                      {x: positionX2 , y:positionY2} ,
                      lYMin , lineWidth , animDuration , bgColor ,
                      {
                        start: markerStat , end:markerEnd
                      }
              );
            }

          }

        }
      }

    }
    return objects;
  }

  function chartTreeY_setSizeChart(svgId , objects , templateOptions ) {
    const svg = document.getElementById(svgId);
    const Width =    templateOptions.hasOwnProperty("W")       ? templateOptions.W       : 100;
    const Height =   templateOptions.hasOwnProperty("H")       ? templateOptions.H       : 100;
    const dHeight =  templateOptions.hasOwnProperty("dH")      ? templateOptions.dH      : 50;
    const marginX =  templateOptions.hasOwnProperty("marginX") ? templateOptions.marginX : 100;
    const marginY =  templateOptions.hasOwnProperty("marginY") ? templateOptions.marginY : 100;

    let width = 0;
    let height = 0;
    for (let i = 0; i < objects.length ; i++) {
      const itemObject = objects[i];
      if (itemObject.hasOwnProperty("row") && itemObject.hasOwnProperty("col")){
        const itemWidth  = itemObject.col*(Width) + Width;
        const itemHeight = (itemObject.row)*(Height+2*dHeight) + (Height+2*dHeight);
        if (itemWidth > width ){
          width = itemWidth
        }
        if (itemHeight > height ){
          height = itemHeight
        }
      }
    }

    svg.setAttribute("width", width + 2*marginX);
    svg.setAttribute("height", height + 2*marginY);
  }

  function chartTreeY_init(svgId , template , templateOptions, objects){
    const svg =document.getElementById(svgId)
    svg.innerHTML = "<defs></defs>"
    svg.style.border = "none"; // Ø­Ø°Ù border

    const tree = chartTreeY_buildTree(objects);
    chartTreeY_assignPositions(tree[0]);
    objects = chartTreeY_flatten(tree);
    objects = chartTreeY_closeLevelDefault(objects , templateOptions);
    objects = chartTreeY_getPosition(objects , templateOptions);
    objects = chartTreeY_getTemplate(objects , template);
    objects = chartTreeY_drawShape(svgId , objects , templateOptions);
    objects = chartTreeY_drawLine(svgId , objects , templateOptions);
    chartTreeY_setSizeChart(svgId , objects , templateOptions);

    return objects;
  }




  function chartRender(objects, levelClose=null , zoomCenter=false){
    return  chartTreeY_init(
            "mysvg" ,
            `
<div style="border: 3px solid black; width:100px;border-radius: 100%; line-height: 100px; height:100px;text-align: center;cursor: pointer" onclick="test({{id}})">{{charName}}</div>
` ,
            {
              W: 100 , H:100 , h:30 , dH:30 ,
              marginX:1000, marginY:1000 , lYMin:20 ,
              lineWidth:2 , animDuration:250 , bgColor:"#9b9b9b" , markerEnd:"arrow" , markerStat:"circle",
              levelClose , zoomCenter
            } ,
            objects
    );
  }

  let objects =  [
    {id:1, parent:0, tags:{charName:"A"}},
    {id:2, parent:1, tags:{charName:"B"}},
    {id:11, parent:1, tags:{charName:"C"}},
    {id:3, parent:1, tags:{charName:"D"}},
    {id:4, parent:2, tags:{charName:"E"}},
    {id:5, parent:2, tags:{charName:"F"}},
    {id:6, parent:2, tags:{charName:"G"}},
    {id:7, parent:2, tags:{charName:"H"}},
    {id:8, parent:3, tags:{charName:"K"}},
    {id:9, parent:3, tags:{charName:"L"}},
    {id:10, parent:9, tags:{charName:"M"}},
    {id:12, parent:9, tags:{charName:"N"}},
    {id:13, parent:11, tags:{charName:"T"}},
  ]
  const levelClose = 2;
  objects = chartRender(objects , levelClose , true);


  function test(id) {
    for (let i = 0; i <objects.length ; i++) {
      const item = objects[i];
      if (item.hasOwnProperty("id") && item.id == id && item.hasOwnProperty("children") && item.children.length > 0){
        objects[i].isOpen = item.hasOwnProperty("isOpen")? !item.isOpen : false;
        const keysToKeep = ["id", "parent", "tags" , "isOpen"];

        objects = objects.map(obj =>
                Object.fromEntries(
                        keysToKeep
                                .filter(key => key in obj) // âœ… Ø´Ø±Ø· ÙˆØ¬ÙˆØ¯ Ú©Ù„ÛŒØ¯
                                .map(key => [key, obj[key]])
                )
        );

        objects = chartRender(objects);
        break;
      }
    }

  }


</script>


